These are a series of bash exploits that exploits a vulnerable C program 
to give an adversary root access to a linux system. 

The program contains various security flaws which are exploited in the
manners described below.

Exploit 1:

This exploit takes advantage of the fact that "chown" in the execlp() calls
does not have an absolute path specified. The user can simply modify the PATH
so that the program first checks for anything called "chown" in
the directory that the user specifies. In this case we chose to search the
BCVS directory for a file called "chown" first. But instead of it being
the intended chown, it is a program that opens a shell with the id of the
current process which is root, effectively escalating the user to root. Then
since we now have a user id of root, the script further escalates the user using
an expect script that logins to superuser which now no longer requires a
password.

To patch this we could simply add an absolute path for the calls on "chown" on
line 190.


Exploit 2:

This exploit takes advantage of the race condition between is_blocked() and
copyFile() on argv[2]. The idea is to have a loop in the background that
constantly switches a symlink between a empty dummy file called "unlock"
and the target file, "block.list" which is normally inaccessible to the student.
What this does is that it causes is_blocked check to sometimes check the dummy
file, then the symlink can randomly switch to block.list and pass into copyFile
and the subsequent chmod/chown to change to sometimes the permissions of the
block.list file maliciously. In addition, a checkin execution will now sometimes
replace block.list with the contents of the (empty) dummy file. This is not
guaranteed, but it just needs to succeed once for the exploit to work. Running
execution and switching in a infinite loops for a couple seconds is enough for
this to happen.

After this happens, block.list is empty so the user now has free reign to
checkin/checkout whatever they want on the system. We then checkin/checkout
a symlink to /etc/passwd and add a new user called root2 with id 0 and with a
hashed password "abc" (or anything we want really) and proceed to login,
gaining root access.

A solution for this would be to add condition checks on information about the
file. Specifically, within its stat struct, the owner, file inode, size,
etc, and make sure it isn't a symlink. We could check this in the beginning
and before we call the functions from before to make sure that there aren't
two files being checked with the same name. 


Exploit 3:

This is almost exactly the same as sploit1 with chown, but the "simplest" fix
would not solve of making just chown an absolute path would not fix this.

Similar to the other case, changing the path will cause the program to search the
BCVS directory for a file called "chmod" first. which is the program that
opens a shell with the id of the current process. Then  with the user id of
root, the script further escalates the user using an expect script that logins
to superuser.

To patch this we could simply add an absolute path for the calls on "chown."
on line 204.


Exploit 4:

This exploits a buffer overflow, specifically src[] and dst[] on lines 137&138.
From GDB, the dst buffer is ($rbp-0x120) or 288 bytes from the base pointer
and the src buffer is ($rbp-d0) or 208 bytes from the base pointer. Which means
to overwrite the return address we'd need at least 208 + 8 bytes for the base
pointer plus 6 bytes for the return address for a total attack string length of
222 bytes. The string that gets copied into these buffers is exactly the
filename string, argv[2]. In order to properly rewrite the return pointer
we must execute bcvs in checkin mode so that src is copied first.

The portion of the stack we are dealing with looks like this right now:

80 byte src buffer + 128 bytes of other vars + 8 byte base pointer + 6 byte ret
which totals to 222 bytes

So we construct our 222 byte attack string as follows:

189 byte No-Op Sled + 27 byte Shellcode + 6 byte Addr to overwrite.

The components are rather self explanatory. We just need to cause the return address
to point somewhere in the no-op slide. Using GDB we initially had a bunch of
'A' characters that appeared as 0x41 values in memory, we would run this
string until it segfaults and then examine the memory locations near $rsp.
Once we located the place where the 'A' characters end, we found the location of
our shell code and added some buffer space to it, acquiring the value of
0x7fffffffe894. Now we can replace the 'A's again with no-ops, running the
program with this constructed string will now cause copyFile to return to the
middle of the buffer filled with no-ops and slide down to our shellcode and
executing it, opening up a terminal.

We tested with GDB in the student directory and found many problems with memory
alignment outside of GDB and if we changed directories. So we had to call the
function directly from the student directory with an absolute path for the
memory addresses to align. 

To fix this overflow problem we could simply just check the size of the string
before it is copied or concatenated.
